# zkverify-poc

End-to-end proof of concept: TLS-attested employer data verified on-chain via zkTLS + ZK proofs on Zeko testnet.

A mock employer HTTPS server serves employee data over TLS 1.2. TLSNotary produces a cryptographic attestation of the TLS session. An o1js ZK circuit proves eligibility predicates over the attested fields (salary, tenure, employment status) without revealing raw values, while verifying the notary's ECDSA/secp256k1 signature in-circuit. The proof is settled on-chain to a `VerificationRegistry` zkApp on Zeko testnet and verified via GraphQL.

## What it does

1. A TLSNotary prover connects to a mock employer HTTPS server and produces a cryptographic attestation of the TLS session.
2. Attested fields (employer name, salary, employment status) are extracted from the attestation.
3. An o1js ZK circuit proves eligibility predicates over those fields without revealing raw values.
4. The proof hash and result are settled on-chain to a `VerificationRegistry` zkApp on Zeko testnet.
5. On-chain state is verified via GraphQL queries against the Zeko node.

## Prerequisites

Install these before starting:

| Dependency | Install |
|---|---|
| [proto](https://moonrepo.dev/proto) | `curl -fsSL https://moonrepo.dev/install/proto.sh \| bash` |
| OpenSSL dev headers | macOS: `brew install openssl` / Debian: `apt install pkg-config libssl-dev` |
| C compiler + build tools | macOS: `xcode-select --install` / Debian: `apt install build-essential` |

proto manages Node, pnpm, moon, and Rust — all versions are pinned in `.prototools`. No need to install them separately.

## Setup

### 1. Clone the repository

```bash
git clone --recurse-submodules https://github.com/zeko-labs/zk-verify-poc.git
cd zk-verify-poc
```

If you already cloned without `--recurse-submodules`, initialize the TLSNotary submodule:

```bash
git submodule update --init --recursive
```

### 2. Install the toolchain

proto reads `.prototools` and installs the pinned versions of Node, pnpm, moon, and Rust:

```bash
proto install
```

### 3. Install dependencies

```bash
pnpm install
```

### 4. Generate wallet keys

```bash
moon run poc:gen-wallet
```

This creates a `.env` file with:
- A Mina fee-payer keypair
- A zkApp keypair
- A TLSNotary signing key
- The Zeko testnet GraphQL URL

Note the `FEE_PAYER_PUBLIC_KEY` printed to the console — you need it for the next step.

### 5. Fund the fee payer

Open the [Zeko faucet](https://zeko.io/faucet), paste the `FEE_PAYER_PUBLIC_KEY` from step 4, and request testnet tokens. Wait for the transaction to confirm before proceeding.

### 6. Deploy the contract

```bash
moon run poc:deploy
```

This compiles and deploys the `VerificationRegistry` zkApp to Zeko testnet. The deployed address is saved to `output/deployed-address.json`.

### 7. Run the pipeline

```bash
moon run workspace:run
```

This runs the full end-to-end pipeline:

| Step | What happens | Output |
|---|---|---|
| 1 | Start mock employer HTTPS server (TLS 1.2) | — |
| 2 | TLSNotary attestation (notary + prover) | `attestation.json` |
| 3 | Extract attested fields | `disclosed-fields.json` |
| 4 | Generate ZK proof (o1js, ~60-120s) | `proof.json`, `verification-key.json` |
| 5 | Verify proof locally | — |
| 6 | Settle proof on-chain (Zeko testnet) | — |
| 7 | Verify on-chain state via GraphQL | — |

Each run creates a timestamped output directory: `output/<timestamp>/`.

### Run the negative flow (optional)

Verify that an ineligible employee is correctly rejected at the proof stage:

```bash
moon run workspace:run-ineligible
```

This targets `EMP-002` (who fails the eligibility policy) and expects the pipeline to fail at `poc:prove`.

## Running individual stages

```bash
moon run mock-server:serve     # start mock HTTPS server
moon run tlsnotary:notary      # start notary server
moon run tlsnotary:prover      # run TLS prover
moon run poc:extract           # extract attested fields
moon run poc:prove             # generate ZK proof
moon run poc:verify            # verify proof locally
moon run poc:deploy            # deploy contract (one-time)
moon run poc:settle            # settle proof on-chain
moon run poc:verify-chain      # verify on-chain state
```

## Development

Run all checks (typecheck + lint + format + tests):

```bash
moon run workspace:validate
```

Test locations:
- `poc/tests/*.spec.ts`
- `mock-server/tests/*.spec.ts`
- Rust unit tests in `tlsnotary/src/*`

## Environment variables

All values live in `.env` (generated by `poc:gen-wallet`, git-ignored).

| Variable | Description |
|---|---|
| `ZEKO_GRAPHQL_URL` | Zeko testnet GraphQL endpoint |
| `FEE_PAYER_PRIVATE_KEY` | Fee payer private key (Base58) |
| `FEE_PAYER_PUBLIC_KEY` | Fee payer public key (Base58) |
| `ZKAPP_PRIVATE_KEY` | zkApp private key (Base58) — used by `deploy` |
| `ZKAPP_PUBLIC_KEY` | zkApp public key (Base58) — used by `settle` and `verify-chain` |
| `TLSNOTARY_SIGNING_KEY_HEX` | TLSNotary signing key (hex) |

Optional runner controls:

| Variable | Default | Description |
|---|---|---|
| `RUN_POC_SERVICE_READY_TIMEOUT_SEC` | `30` | Timeout waiting for services |
| `RUN_POC_SERVICE_READY_POLL_INTERVAL_SEC` | `1` | Poll interval for readiness checks |
| `RUN_POC_SKIP_READY_CHECK` | `0` | Skip readiness checks (testing only) |

## Output artifacts

Per-run (in `output/<timestamp>/`):
- `attestation.json` — TLSNotary attestation
- `disclosed-fields.json` — extracted employer fields
- `proof.json` — ZK proof
- `verification-key.json` — circuit verification key

Fixed:
- `output/deployed-address.json` — deployed zkApp metadata

## UI (Nuxt SPA)

A client-side Nuxt SPA at `ui/` lets you browse proof runs.

Hosted: https://zkverify-poc-ui.zeko-labs.workers.dev/

Run locally (after running the pipeline at least once):

```bash
moon run ui:dev
```

Build and deploy to Cloudflare Workers:

```bash
moon run ui:build
moon run ui:deploy
```

## Security model and boundaries

Implemented hardening in this repository:

- Settlement requires a typed ZK proof object in `VerificationRegistry.recordVerification`; the contract verifies it in-circuit before mutating state.
- The eligibility circuit pins a trusted notary secp256k1 public key and does not accept prover-chosen key/policy witness values.
- Eligibility policy values are fixed for the PoC circuit (`salary >= 50,000`, `tenure >= 12 months`, `status == active`, evaluation date `2026-02-18`).
- The circuit binds business data to a Poseidon hash of the TLS response body (`responseBodyHash`), which is exposed as a public output. Off-chain verification confirms this hash matches the attestation's response body. This prevents data substitution attacks where fabricated values are paired with a valid ECDSA signature.
- TLS prover request inputs are sanitized to reject CRLF/header-injection payloads.
- Pipeline startup waits for active service readiness (mock server + notary) instead of fixed sleeps.

**Known PoC limitation:** The circuit does not yet verify that the response body is included in the session header's transcript commitments (full transcript byte-range inclusion proofs). The binding from ECDSA-signed session header to specific response body bytes remains an off-chain trust assumption.

## Path to full on-chain trust

The current hybrid binding (response body hash as public output + off-chain verification) closes the primary data substitution attack but still relies on an off-chain step to link the response body to the TLS session. Full on-chain trust requires eliminating this off-chain dependency:

1. **BLAKE3 circuit gadget** -- TLSNotary's transcript commitments use BLAKE3 hashes. Implementing BLAKE3 verification inside o1js would allow the circuit to verify `PlaintextHash` commitments directly. This is a significant R&D effort (~50k+ constraints per invocation).
2. **Session header parsing** -- The 54-byte BCS-encoded session header contains a Merkle root (bytes 22-53) over all attestation body fields, including transcript commitments. The circuit must extract this root via fixed-offset byte slicing.
3. **Merkle inclusion proof** -- Provide sibling hashes proving the response body's `PlaintextHash` leaf is included under the session header's Merkle root. Verify the path in-circuit.
4. **JSON field extraction proofs** -- Prove in-circuit that specific byte ranges of the response body decode to the claimed salary/hire_date/status values. This may require a structured response format (e.g., fixed-offset binary encoding) instead of free-form JSON.

Until these are implemented, the off-chain binding step is the trust boundary. Verifiers must independently re-hash the attestation response body and confirm it matches the proof's `responseBodyHash` public output.

## Project layout

```
zkverify-poc/
├── run-poc.sh                  # full pipeline orchestrator
├── run-poc-ineligible.sh       # negative-flow runner
├── .prototools                 # pinned toolchain versions
├── pnpm-workspace.yaml         # workspace packages + dependency catalog
├── mock-server/                # HTTPS fixture server (TLS 1.2)
│   ├── server.ts
│   └── tests/
├── tlsnotary/                  # Rust notary + prover binaries
│   ├── Cargo.toml
│   └── src/bin/{notary,prover}.rs
├── poc/                        # TypeScript proving/settlement pipeline
│   ├── circuits/eligibility.ts # o1js ZkProgram
│   ├── contracts/              # VerificationRegistry zkApp
│   ├── extract-fields.ts
│   ├── prove.ts
│   ├── verify.ts
│   ├── deploy.ts
│   ├── settle.ts
│   ├── verify-chain.ts
│   └── tests/
├── ui/                         # Nuxt SPA proof explorer
├── vendor/tlsn/                # TLSNotary git submodule
└── output/                     # generated artifacts (git-ignored)
```
