# zkVerify PoC — Build Specification

## CLI-Based Technical Validation for ZK-Verified Employment Verification on Zeko

**Version:** 1.0
**Date:** February 18, 2026
**Type:** Proof of Concept — local CLI pipeline, no UI, no services, no cloud

---

## 0. Additional Requirements Captured During Implementation

These requirements were provided after the initial PRD and are now treated as binding for this repo:

- Use a fresh git repository initialization.
- Use latest `node` and `pnpm`, managed through `proto`.
- Use `moon` for task orchestration.
- Organize the repo by moon projects (`workspace`, `poc`, `mock-server`, `tlsnotary`) with tests colocated inside each project directory.
- Use a pnpm workspace with package `poc/` and keep Node dependency versions in pnpm catalog.
- Vendor TLSNotary as a git submodule (`vendor/tlsn`) for fresh upstream access.
- Keep sensitive keys local and git-ignored; generate wallet keys into `.env` for funding.
- Prefer strict full ECDSA flow (fail hard on attestation incompatibility).
- Enforce Red/Green/Refactor TDD with BDD-style test naming.
- Keep a live implementation tracker in `TASKLIST.md`; do not substitute moon tasks for planning state.
- Keep continuation state in `README.md`, `PRD.md`, and `TASKLIST.md` (no separate handoff file).
- Validate TypeScript with Microsoft TypeScript Go (`tsgo`) and enforce lint/format with `oxlint`/`oxfmt`.

Security scope clarifications for this PoC:
- This PoC intentionally does not implement full transcript byte-range inclusion proofs for disclosed business fields. That limitation is expected and remains out-of-scope for the PoC acceptance boundary.
- Even with that limitation, implement all non-limitation hardening items discovered during review (for example: trusted notary key pinning, verifier-visible/fixed policy constraints, in-contract proof verification, request sanitization, and startup readiness reliability).

---

## 1. What We're Building and Why

### The Product (Context)

**zkVerify** is a zero-knowledge proof layer for privacy-preserving employment and income verification, settled on the Zeko blockchain (a zkRollup on Mina Protocol).

The business scenario: a payroll data vendor sits between employers (who hold employee data in HRIS systems like Workday/ADP) and lenders (who need proof of employment before approving a loan). Today, the vendor fetches employee records, checks eligibility rules (e.g., "salary >= $50,000 and employed >= 12 months"), and returns a yes/no answer. The lender trusts this blindly — no cryptographic proof it's correct, no proof the data came from the real employer, and the vendor sees far more data than necessary.

zkVerify wraps this flow with three cryptographic layers:

1. **TLS attestation** (via TLSNotary) — proving the employee data genuinely came from the employer's HRIS API, not fabricated by the vendor
2. **ZK computation** (via o1js) — proving an eligibility rule was correctly applied to the attested data without revealing the raw data
3. **On-chain settlement** (via Zeko) — posting the proof to Zeko so any party can independently verify it

### The PoC (What This Document Specifies)

This PoC validates that the **core cryptographic pipeline works end-to-end**. Specifically:

1. Can TLSNotary attest a TLS 1.2 session and produce an ECDSA/secp256k1 signed attestation?
2. Can an o1js ZkProgram verify that ECDSA signature inside a ZK circuit alongside eligibility rule checks?
3. Can a proof generated by that circuit be posted to and verified on Zeko testnet?

**This PoC is:**
- A set of CLI scripts and Rust binaries that run sequentially on a single machine
- A pipeline: mock server → TLSNotary attestation → field extraction → ZK proof generation → local verification → Zeko settlement
- Designed to validate the cryptographic pipeline, not to be production code

**This PoC is NOT:**
- A product demo (no UI, no API, no database)
- Architecturally representative of the final product
- Production code (minimal error handling, hardcoded values, happy path only)

---

## 2. The Cryptographic Pipeline

### How TLSNotary Works

TLSNotary (https://github.com/tlsnotary/tlsn) is a protocol that adds a Verifier to a TLS connection using secure Multi-Party Computation (MPC):

- A **Prover** (our system) and a **Notary** (independent witness) jointly participate in the TLS handshake with a target server
- The TLS session keys are split between them via MPC — neither party holds the full key
- The Prover sends HTTP requests and receives responses normally
- The Notary sees only encrypted traffic and metadata (timing, length, cipher suite) but never the plaintext
- From the server's perspective, this looks like a standard TLS connection
- After the session, the Notary produces a **Session Header** containing commitments to the transcript data
- The Notary **signs** this Session Header. The Prover can then selectively disclose parts of the response.

**Critical constraint:** TLSNotary currently supports **TLS 1.2 only**. The target server must speak TLS 1.2.

**Recent development (relevant to this PoC):** TLSNotary added support for **secp256k1 signatures** for the Notary's attestation signing. This is important because o1js (the ZK framework for Mina/Zeko) has a native ECDSA verification gadget for secp256k1, meaning we can potentially verify the Notary's signature *inside* a ZK circuit.

### The ZKON Bridge Pattern

ZKON Network (https://github.com/ZKON-Network) built a zkTLS oracle integration for Mina Protocol that bridges TLSNotary attestations to on-chain verification. Their approach, which we adapt for Zeko:

1. The Notary signs the TLS session header using **ECDSA over secp256k1**
2. An **o1js ZkProgram** verifies that ECDSA signature in-circuit using the Notary's known public key
3. The same ZkProgram applies business logic to the attested data
4. **One proof** covers both data provenance and computation correctness
5. That proof gets posted to chain

Key ZKON implementation details (from their `zkTLS-Mina-Oracle` repo):
- The ZkProgram performs two checks: ECDSA signature verification and a data commitment check
- The session header (serialized) is the message being verified
- The Notary's public key is a circuit constant
- o1js's `createForeignCurve(Crypto.CurveParams.Secp256k1)` and `createEcdsa()` are used for in-circuit ECDSA verification
- ECDSA verification in o1js costs ~30,000 constraints

**What we take from ZKON:** The ZkProgram pattern — in-circuit ECDSA signature verification of the Notary's attestation.

**What we skip from ZKON:** Their IPFS-based request routing, two-transaction on-chain pattern, ZKON token payments, and hosted coordinator service. Our PoC is a direct local pipeline.

### o1js ECDSA Verification

o1js (https://docs.o1labs.org/o1js/) provides native ECDSA verification over foreign curves. The relevant APIs:

```typescript
import { Crypto, createForeignCurve, createEcdsa } from 'o1js';

class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}
class Ecdsa extends createEcdsa(Secp256k1) {}

// Inside a ZkProgram method:
signature.verify(message, publicKey).assertTrue();
```

Documentation: https://docs.minaprotocol.com/zkapps/o1js/ecdsa

### Zeko

Zeko (https://docs.zeko.io/) is a zkRollup on Mina Protocol. It uses the same o1js framework for zkApp development. For this PoC, we deploy to Zeko testnet and post proofs there.

- Getting started: https://docs.zeko.io/developers/getting-started.html
- Testnet faucet: https://zeko.io/faucet

---

## 3. End-to-End Pipeline

```
┌─────────────────────────────────────────────────────────┐
│                    Local Machine                         │
│                                                         │
│  ┌──────────────┐     ┌──────────────────────────────┐  │
│  │ Mock HTTPS    │◄────│ TLSNotary Prover (Rust)      │  │
│  │ Server        │     │                              │  │
│  │ (TLS 1.2)    │     │ Communicates with Notary      │  │
│  │ Port 4443    │     │ via localhost TCP              │  │
│  └──────────────┘     └──────────┬───────────────────┘  │
│                                  │                       │
│  ┌──────────────┐                │ attestation.json      │
│  │ TLSNotary     │◄───TCP────────┘                       │
│  │ Notary        │                                       │
│  │ Port 7047    │                                       │
│  └──────────────┘                                       │
│                                                         │
│                       ┌──────────────────────────────┐  │
│  attestation.json ───►│ Field Extractor (TS script)   │  │
│                       │                              │  │
│                       │ Parses attestation, extracts  │  │
│                       │ salary/hire_date/status,      │  │
│                       │ computes Poseidon hash        │  │
│                       └──────────┬───────────────────┘  │
│                                  │                       │
│                       disclosed-fields.json              │
│                                  │                       │
│                       ┌──────────▼───────────────────┐  │
│                       │ ZK Prover (o1js script)       │  │
│                       │                              │  │
│                       │ 1. Verify ECDSA sig           │  │
│                       │ 2. Check eligibility rules    │  │
│                       │ 3. Generate proof             │  │
│                       └──────────┬───────────────────┘  │
│                                  │                       │
│                       proof.json + verification-key.json │
│                                  │                       │
│                       ┌──────────▼───────────────────┐  │
│                       │ Settlement Script (o1js)      │  │
│                       │                              │  │
│                       │ Posts proof to Zeko testnet    │──────► Zeko Testnet
│                       │ via GraphQL                   │
│                       └──────────────────────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Expected CLI Output

```
$ ./run-poc.sh

[1/6] Starting mock employer HTTPS server (TLS 1.2)...
       → Listening on https://localhost:4443

[2/6] Running TLSNotary attestation...
       → Prover connecting to https://localhost:4443/api/v1/employee/EMP-001
       → Notary co-signing TLS session
       → Attestation complete
       → Session header signed with ECDSA/secp256k1
       → Notary public key: 0x04abc...
       → Saved: attestation.json

[3/6] Extracting attested fields (selective disclosure)...
       → Disclosed: annual_salary=85000, hire_date=2023-06-15, employment_status=active
       → Redacted: ssn_last4, first_name, last_name, ...
       → Saved: disclosed-fields.json

[4/6] Generating ZK proof (o1js)...
       → Compiling circuit... (this takes ~60s)
       → Verifying ECDSA signature in-circuit...
       → Checking eligibility: salary >= 50000 ✓, tenure >= 12 months ✓, status == active ✓
       → Proof generated
       → Saved: proof.json, verification-key.json

[5/6] Verifying proof locally...
       → Proof valid: true

[6/6] Posting proof to Zeko testnet...
       → Transaction hash: 5Jt...xyz
       → Block explorer: https://zekoscan.io/testnet/tx/5Jt...xyz
       → On-chain verification: confirmed

✅ End-to-end pipeline complete.
   Total time: ~3 minutes
   Result: ELIGIBLE
```

### File Flow

```
run-poc.sh
  │
  ├── 1. starts mock-server (background process)
  │
  ├── 2. runs tlsnotary-attest (Rust binary)
  │       └── writes: output/attestation.json
  │
  ├── 3. runs extract-fields.ts
  │       ├── reads:  output/attestation.json
  │       └── writes: output/disclosed-fields.json
  │
  ├── 4. runs prove.ts
  │       ├── reads:  output/disclosed-fields.json
  │       └── writes: output/proof.json, output/verification-key.json
  │
  ├── 5. runs verify.ts
  │       ├── reads:  output/proof.json, output/verification-key.json
  │       └── prints: valid/invalid
  │
  └── 6. runs settle.ts
          ├── reads:  output/proof.json, output/deployed-address.json
          └── prints: transaction hash, block explorer link
```

---

## 4. Component Specifications

### 4.1 Mock HTTPS Server

**Language:** TypeScript (Node.js)
**Complexity:** ~50 lines
**File:** `poc/mock-server/server.ts`

A minimal HTTPS server with a self-signed certificate locked to TLS 1.2.

**Requirements:**
- Serve on `https://localhost:4443`
- TLS config: `minVersion: 'TLSv1.2'`, `maxVersion: 'TLSv1.2'` in Node's `https.createServer` options
- Self-signed cert generated via `openssl` (generate and commit `cert.pem` + `key.pem` to repo)
- Single endpoint: `GET /api/v1/employee/EMP-001`
- Returns hardcoded JSON — no Faker.js, no database, just a constant object:

```json
{
  "employee_id": "EMP-001",
  "first_name": "Jane",
  "last_name": "Doe",
  "ssn_last4": "1234",
  "employment_status": "active",
  "hire_date": "2023-06-15",
  "annual_salary": 85000,
  "employer_name": "Acme Corp"
}
```

**Cert generation command (for README):**
```bash
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes \
  -subj "/CN=localhost" -addext "subjectAltName=DNS:localhost,IP:127.0.0.1"
```

**Risk being validated:** Does TLSNotary work with a localhost self-signed cert over TLS 1.2? If it requires a real CA-signed cert, the PoC surfaces this immediately. May need to disable cert verification in TLSNotary's Prover config for local testing.

---

### 4.2 TLSNotary Attestation

**Language:** Rust
**Complexity:** Moderate — adapting TLSNotary's existing examples
**Base code:** https://github.com/tlsnotary/tlsn/tree/main/crates/examples
**Files:**
```
poc/tlsnotary/Cargo.toml
poc/tlsnotary/src/bin/notary.rs    — the Notary server
poc/tlsnotary/src/bin/prover.rs    — the Prover client
```

**Notary (`notary.rs`):**
- Runs on `localhost:7047`
- Configured with a **secp256k1** signing key (generate a keypair and hardcode for PoC)
- Accepts Prover connections, participates in MPC-TLS handshake
- Signs the session header with ECDSA/secp256k1 after session completes

**Implementation guidance:**
- Start from TLSNotary's `simple_notary.rs` example
- The key configuration change is specifying secp256k1 as the signing algorithm. Check TLSNotary's `CryptoProvider` API — recent releases added extensible cryptographic algorithms including secp256k1 signatures
- The Notary should bind to `127.0.0.1:7047` and accept a single connection

**Prover (`prover.rs`):**
- Connects to Notary on `localhost:7047`
- Initiates MPC-TLS session to `https://localhost:4443/api/v1/employee/EMP-001`
- Receives and decrypts the server's response (only the Prover sees plaintext)
- Receives the signed attestation from the Notary
- Writes `output/attestation.json`

**Implementation guidance:**
- Start from TLSNotary's `simple_prover.rs` example
- For self-signed certs: the Prover's TLS configuration may need to disable certificate verification. TLSNotary uses `rustls` internally — check if there's a way to add a custom root CA or skip verification for localhost.
- The MPC-TLS handshake between Prover and Notary happens over a separate TCP channel (not the TLS connection to the server)

**Expected output — `attestation.json`:**

The exact format depends on TLSNotary's API, but we need to extract at minimum:

```json
{
  "session_header": "<hex-encoded serialized session header bytes>",
  "signature": {
    "r": "<hex-encoded r component>",
    "s": "<hex-encoded s component>"
  },
  "notary_public_key": {
    "x": "<hex-encoded x coordinate>",
    "y": "<hex-encoded y coordinate>"
  },
  "response_body": "{\"employee_id\":\"EMP-001\",\"first_name\":\"Jane\",...}",
  "server_name": "localhost",
  "timestamp": 1708000000
}
```

**Important: Inspect the actual output carefully.** The format of `session_header`, `signature`, and the relationship between them is the most critical unknown in this PoC. Document exactly:
- What bytes does the Notary sign? (The serialized session header? A hash of it? What hash function?)
- What encoding is the signature in? (DER? Raw r,s concatenation? Both as big-endian byte arrays?)
- What format is the public key in? (Compressed? Uncompressed? SEC1?)

This information is needed to correctly feed data into the o1js ECDSA verification gadget in step 4.

**Risks being validated:**
- Is secp256k1 signing exposed through a usable/stable TLSNotary API?
- Can TLSNotary attest a self-signed cert connection?
- What is the exact attestation output format?
- What's the actual latency on localhost?

---

### 4.3 Field Extractor

**Language:** TypeScript (using o1js for Poseidon hashing)
**Complexity:** ~100 lines
**File:** `poc/extract-fields.ts`

This script bridges TLSNotary's output (arbitrary JSON) to o1js circuit inputs (Field elements).

**Steps:**
1. Read `output/attestation.json`
2. Parse `response_body` as JSON
3. Extract three fields: `annual_salary`, `hire_date`, `employment_status`
4. Convert to circuit-compatible types:
   - `salary`: number → keep as-is (will become `UInt64` in circuit)
   - `hire_date`: ISO date string "2023-06-15" → Unix timestamp in milliseconds (e.g., `1686787200000`)
   - `employment_status`: string "active" → Poseidon hash of the UTF-8 bytes (using o1js `Poseidon.hash()`)
5. Compute a **Poseidon hash commitment** of all three values: `Poseidon.hash([salary, hireDateUnix, statusHash])`
6. Preserve the ECDSA signature, session header, and notary public key from the attestation
7. Write `output/disclosed-fields.json`:

```json
{
  "salary": 85000,
  "hire_date_unix": 1686787200000,
  "status_hash": "<poseidon hash of 'active' as Field string>",
  "data_commitment": "<poseidon hash of [salary, hire_date, status_hash] as Field string>",
  "ecdsa_signature": {
    "r": "<hex from attestation>",
    "s": "<hex from attestation>"
  },
  "session_header_bytes": "<hex from attestation — the message that was signed>",
  "notary_public_key": {
    "x": "<hex from attestation>",
    "y": "<hex from attestation>"
  }
}
```

**Note on selective disclosure:** Full selective disclosure happens at the byte-range level within TLSNotary's protocol (reveal specific byte ranges of the encrypted response). This PoC skips that complexity and simply parses the full JSON response. The TLSNotary attestation still provides the trust anchor via the ECDSA signature over the session header, but transcript-range inclusion for each disclosed field is not yet proven inside the o1js circuit. This is an explicit limitation and a known hardening area.

---

### 4.4 ZK Prover — o1js ZkProgram

**Language:** TypeScript (o1js)
**Complexity:** ~200 lines — the core of the PoC
**Files:**
```
poc/circuits/eligibility.ts    — the ZkProgram definition
poc/prove.ts                   — script that compiles the circuit and generates a proof
```

#### Circuit Design

The ZkProgram performs two verification steps in a single proof:

**Step A — Attestation Verification:** Verify the Notary's ECDSA/secp256k1 signature over the session header using a trusted, pinned Notary public key.

**Step B — Eligibility Check:** Verify that the attested employment data satisfies the business rules (salary >= threshold, tenure >= minimum months, status == active).

```typescript
// Illustrative pseudocode — adapt to actual o1js API

import {
  ZkProgram, Field, Bool, UInt64, Poseidon,
  Crypto, createForeignCurve, createEcdsa, Bytes
} from 'o1js';

// Set up secp256k1 curve and ECDSA
class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}
class EcdsaSig extends createEcdsa(Secp256k1) {}

// Define the byte length class for the session header message
// The exact length depends on TLSNotary's output — adjust after Step 2
class SessionHeaderBytes extends Bytes(N) {}  // N = actual byte length

const EligibilityProgram = ZkProgram({
  name: 'employment-eligibility',
  publicInput: Field,    // data commitment (Poseidon hash)
  publicOutput: Bool,    // eligible: true/false

  methods: {
    verify: {
      privateInputs: [
        UInt64,           // salary
        UInt64,           // hire_date_unix (ms)
        Field,            // status_hash (Poseidon hash of "active")
        EcdsaSig,         // Notary's ECDSA signature
        Secp256k1,        // Notary's public key
        SessionHeaderBytes, // The signed message (session header)
        UInt64,           // min_salary (rule parameter)
        UInt64,           // min_tenure_months (rule parameter)
        UInt64,           // current_date_unix (ms)
        Field,            // required_status_hash (Poseidon hash of "active")
      ],

      async method(
        dataCommitment: Field,
        salary: UInt64,
        hireDateUnix: UInt64,
        statusHash: Field,
        signature: typeof EcdsaSig,
        notaryPubKey: typeof Secp256k1,
        sessionHeader: typeof SessionHeaderBytes,
        minSalary: UInt64,
        minTenureMonths: UInt64,
        currentDateUnix: UInt64,
        requiredStatusHash: Field
      ) {
        // Step A: Verify attestation
        // 1. Check that private inputs match the claimed data commitment
        const computed = Poseidon.hash([
          salary.toField(),
          hireDateUnix.toField(),
          statusHash,
        ]);
        computed.assertEquals(dataCommitment);

        // 2. Verify the Notary's ECDSA signature over the session header
        signature.verify(sessionHeader, notaryPubKey).assertTrue();

        // Step B: Check eligibility rules
        // 3. Employment status must be "active"
        statusHash.assertEquals(requiredStatusHash);

        // 4. Salary must meet minimum
        salary.assertGreaterThanOrEqual(minSalary);

        // 5. Tenure must meet minimum
        const tenureMs = currentDateUnix.sub(hireDateUnix);
        const thirtyDaysMs = UInt64.from(2_592_000_000); // 30 days in ms
        const tenureMonths = tenureMs.div(thirtyDaysMs);
        tenureMonths.assertGreaterThanOrEqual(minTenureMonths);

        return { publicOutput: Bool(true) };
      }
    }
  }
});
```

**Important notes on the circuit:**

1. **ECDSA verification is expensive.** Expect ~30,000 constraints for the signature verification alone. Combined with Poseidon hashing and UInt64 comparisons, total proof generation time will likely be 60-120 seconds.

2. **The `Bytes(N)` class must match the exact session header length.** After step 2 (TLSNotary attestation), inspect the session header byte length and hardcode it. o1js circuits are static — the size must be known at compile time.
3. **Use a trusted notary key anchor.** Do not allow the prover to choose the notary key as an unconstrained private input.
4. **Rule parameters must be verifier-visible or fixed.** Do not accept prover-chosen private rule thresholds.

5. **Signature encoding must match exactly.** o1js's `createEcdsa` expects the signature in a specific format. TLSNotary may produce DER-encoded signatures or raw (r, s) bigints. A conversion may be necessary in `extract-fields.ts`.

6. **The "message" that was signed matters.** o1js's ECDSA verify internally hashes the message. Check whether TLSNotary signs the raw session header bytes or a SHA-256 hash of them. If TLSNotary signs `SHA256(session_header)`, you may need to pass the pre-hashed value and use the appropriate verify method.

#### prove.ts Script

```
File: poc/prove.ts
```

1. Load `output/disclosed-fields.json`
2. Instantiate all circuit inputs from the loaded data
3. Compile the circuit: `await EligibilityProgram.compile()` — this is slow (~60s), only done once
4. Generate the proof: `await EligibilityProgram.verify({ ... })`
5. Serialize and write `output/proof.json`
6. Write `output/verification-key.json` (from the compilation output)

---

### 4.5 Local Verifier

**Language:** TypeScript (o1js)
**Complexity:** ~30 lines
**File:** `poc/verify.ts`

1. Load `output/proof.json` and `output/verification-key.json`
2. Deserialize the proof
3. Call verification: `await EligibilityProgram.verify(proof)`
4. Print `Proof valid: true` or `Proof valid: false`

This is trivial but confirms proof serialization and deserialization work correctly.

---

### 4.6 Zeko Settlement

**Language:** TypeScript (o1js)
**Complexity:** ~150 lines
**Files:**
```
poc/contracts/VerificationRegistry.ts   — the zkApp (smart contract)
poc/deploy.ts                           — one-time deployment to Zeko testnet
poc/settle.ts                           — posts a proof to the deployed zkApp
```

#### VerificationRegistry zkApp (Minimal)

```typescript
import { SmartContract, state, State, Field, method, UInt64, Struct } from 'o1js';

class VerificationEvent extends Struct({
  proofHash: Field,
  result: Field,
}) {}

class VerificationRegistry extends SmartContract {
  @state(Field) lastProofHash = State<Field>();
  @state(Field) lastResult = State<Field>();

  events = {
    verification: VerificationEvent,
  };

  @method async recordVerification(
    proofHash: Field,
    result: Field,
  ) {
    this.lastProofHash.set(proofHash);
    this.lastResult.set(result);

    this.emitEvent('verification', new VerificationEvent({
      proofHash,
      result,
    }));
  }
}
```

This is deliberately minimal. No Merkle tree, no history, no access control. The goal is to prove we can post data to Zeko and read it back.

#### deploy.ts

1. Generate a keypair for the zkApp account (or load from a file if already generated)
2. Fund the account via Zeko testnet faucet (https://zeko.io/faucet) — this may be a manual step
3. Connect to Zeko testnet via the GraphQL endpoint (check https://docs.zeko.io/developers/getting-started.html for the current URL)
4. Compile `VerificationRegistry`
5. Deploy the zkApp
6. Wait for deployment transaction to confirm
7. Save the deployed address to `output/deployed-address.json`

**Note:** Deployment is a one-time setup step, not part of the main `run-poc.sh` pipeline. Run it once before running the full pipeline.

#### settle.ts

1. Load `output/proof.json` and `output/deployed-address.json`
2. Compute a Poseidon hash of the serialized proof (this is the `proofHash`)
3. Connect to Zeko testnet
4. Call `recordVerification(proofHash, result)` on the deployed zkApp
5. Wait for transaction confirmation
6. Print the transaction hash and block explorer URL

**Interaction with Zeko:** Use o1js's `Mina.Network()` to connect to Zeko's GraphQL endpoint. The Lumina DEX project (https://github.com/Lumina-DEX/lumina/blob/main/packages/signer/src/graphql.ts) provides a reference for how to interact with Mina-compatible chains via GraphQL from TypeScript.

---

## 5. Repository Structure

```
zkverify-poc/
├── README.md                    # Setup instructions, prerequisites, how to run
├── run-poc.sh                   # The single script that runs the full pipeline
├── package.json                 # Workspace root package metadata
├── pnpm-workspace.yaml          # Workspace packages + dependency catalog
├── tsconfig.json
│
├── mock-server/
│   ├── server.ts                # ~50 lines, hardcoded employee JSON
│   ├── cert.pem                 # Self-signed TLS 1.2 cert (generated, committed)
│   └── key.pem                  # Private key for cert
│
├── poc/
│   ├── package.json             # PoC Node package dependencies
│   ├── moon.yml                 # PoC moon tasks
│   ├── extract-fields.ts        # attestation.json → disclosed-fields.json
│   ├── prove.ts                 # Compile circuit + generate proof
│   ├── verify.ts                # Local proof verification
│   ├── deploy.ts                # One-time Zeko zkApp deployment
│   ├── settle.ts                # Post proof hash to Zeko
│   ├── circuits/
│   │   └── eligibility.ts       # The o1js ZkProgram definition
│   ├── contracts/
│   │   └── VerificationRegistry.ts  # Minimal Zeko zkApp
│   └── tests/
│       └── *.spec.ts            # PoC tests
│
├── tlsnotary/
│   ├── Cargo.toml               # Rust dependencies — tlsn crates
│   ├── Cargo.lock
│   └── src/
│       └── bin/
│           ├── notary.rs        # Notary server (adapted from TLSNotary examples)
│           └── prover.rs        # Prover client (adapted from TLSNotary examples)
│
└── output/                      # Generated artifacts (gitignored except .gitkeep)
    ├── .gitkeep
    ├── attestation.json         # Written by prover.rs
    ├── disclosed-fields.json    # Written by extract-fields.ts
    ├── proof.json               # Written by prove.ts
    ├── verification-key.json    # Written by prove.ts
    └── deployed-address.json    # Written by deploy.ts
```

---

## 6. Prerequisites

| Dependency | Version | Purpose |
|------------|---------|---------|
| Rust | stable (1.75+) | TLSNotary Prover and Notary binaries |
| Node.js | 20+ | o1js requires Node 20+ |
| npm or pnpm | latest | Package management |
| o1js | latest stable | ZK circuits, Poseidon hashing, Zeko interaction |
| openssl | any | Generate self-signed TLS certificate |
| Zeko testnet tokens | — | Fund the zkApp account via faucet |

**No Docker, no databases, no cloud accounts required.**

**npm dependencies (package.json):**
- `o1js` — ZK framework
- `tsx` — run TypeScript directly without separate compilation

**Rust dependencies (Cargo.toml):**
- `tlsn-prover`, `tlsn-verifier`, `tlsn-core` — TLSNotary crates
- `tokio` — async runtime
- `hyper` / `hyper-tls` — HTTP client
- `serde`, `serde_json` — JSON serialization
- Pin to a specific TLSNotary release tag (check https://github.com/tlsnotary/tlsn/releases for latest stable)

---

## 7. run-poc.sh Script

```bash
#!/bin/bash
set -e

echo ""
echo "========================================="
echo "  zkVerify PoC — End-to-End Pipeline"
echo "========================================="
echo ""

# Step 1: Start mock server
echo "[1/6] Starting mock employer HTTPS server (TLS 1.2)..."
moon run mock-server:serve &
MOCK_PID=$!
sleep 2
echo "       → Listening on https://localhost:4443"
echo ""

# Step 2: TLSNotary attestation
echo "[2/6] Running TLSNotary attestation..."
# Start Notary in background
moon run tlsnotary:notary &
NOTARY_PID=$!
sleep 3
# Run Prover
moon run tlsnotary:prover
echo "       → Saved: output/attestation.json"
echo ""

# Step 3: Extract fields
echo "[3/6] Extracting attested fields..."
moon run poc:extract
echo "       → Saved: output/disclosed-fields.json"
echo ""

# Step 4: Generate ZK proof
echo "[4/6] Generating ZK proof (o1js)..."
echo "       → Compiling circuit... (this takes ~60-120s)"
moon run poc:prove
echo "       → Saved: output/proof.json, output/verification-key.json"
echo ""

# Step 5: Verify locally
echo "[5/6] Verifying proof locally..."
moon run poc:verify
echo ""

# Step 6: Post to Zeko
echo "[6/6] Posting proof to Zeko testnet..."
moon run poc:settle
echo ""

# Cleanup
kill $MOCK_PID 2>/dev/null || true
kill $NOTARY_PID 2>/dev/null || true

echo "✅ End-to-end pipeline complete."
```

---

## 8. Known Unknowns — What This PoC Must Answer

Each of these is a question we cannot answer from documentation alone. The PoC is designed to produce concrete answers.

### 8.1 TLSNotary secp256k1 API Availability

**Question:** Is secp256k1 signing exposed through a stable, usable API in the current TLSNotary release?

**How the PoC answers it:** Step 2 — if the Notary can be configured to sign with secp256k1 and the Prover can extract the signature, it works. If not, we discover what's actually available.

**Impact of failure:** Fall back to two-step verification — verify TLSNotary's attestation off-circuit (using whatever signature scheme it supports), then have the o1js circuit only check eligibility rules against a Poseidon commitment of the data. Two separate checks instead of one proof.

### 8.2 ECDSA Signature Format Compatibility (TLSNotary ↔ o1js)

**Question:** Does o1js's `createEcdsa(Secp256k1).verify()` accept the exact signature format TLSNotary produces?

**How the PoC answers it:** Step 4 — if the proof generates with the ECDSA verification constraint, they're compatible. If not, we identify the exact encoding mismatch (DER vs raw, hash function, endianness).

**Impact of failure:** A conversion layer is needed. The mismatch is solvable — it's a matter of encoding, not cryptographic incompatibility — but it must be identified precisely.

### 8.3 TLSNotary + Self-Signed Certificates

**Question:** Can TLSNotary attest a TLS session to a server with a self-signed certificate?

**How the PoC answers it:** Step 2 — either the MPC-TLS handshake completes or it rejects the connection.

**Impact of failure:** Either disable cert verification in TLSNotary for local dev (acceptable for PoC), or use a real CA-signed cert (complicates local development), or build the mock server in Rust using `rustls` with custom cert handling.

### 8.4 TLS 1.2 Enforcement

**Question:** Can we force a Node.js HTTPS server to speak only TLS 1.2, and does TLSNotary successfully handshake with it?

**How the PoC answers it:** Steps 1 + 2 — if the MPC-TLS handshake completes, it works.

**Impact of failure:** Build the mock server in Rust with `rustls` explicitly configured for TLS 1.2 only.

### 8.5 Zeko Testnet + o1js Compatibility

**Question:** Does the current stable o1js version work with Zeko testnet for zkApp deployment and transaction submission?

**How the PoC answers it:** Steps 5 + 6 — deploy and settle. Either transactions confirm or they don't.

**Impact of failure:** May need a specific o1js version, or Zeko may require a wrapper/fork. This has occurred with other Mina L2s before.

### 8.6 Combined Circuit Size and Proof Generation Time

**Question:** How long does proof generation take when combining ECDSA verification (~30k constraints) with Poseidon hashing and eligibility checks?

**How the PoC answers it:** Step 4 — we time it on real hardware.

**Impact if slow (>3 min):** Split into two ZkPrograms — one for ECDSA verification, one for eligibility — composed recursively. o1js supports this via ZkProgram proof composition but it adds complexity.

### 8.7 Session Header Serialization

**Question:** What exact bytes does TLSNotary's Notary sign? How is the session header serialized? What hash function is applied before signing?

**How the PoC answers it:** Step 2 output — inspect `attestation.json` and trace through TLSNotary's code to understand the exact signing input.

**Impact of unclear answer:** The conversion from TLSNotary's output format to o1js ECDSA inputs is the single most fragile integration point. Getting the message bytes wrong means signatures that verify off-circuit but fail in-circuit (or vice versa).

---

## 9. Pass/Fail Criteria

| # | Criterion | Pass | Fail |
|---|-----------|------|------|
| 1 | TLSNotary produces an ECDSA/secp256k1 signed attestation from a TLS 1.2 session | Attestation file with valid secp256k1 signature | TLSNotary only supports P256, or TLS 1.2 handshake fails |
| 2 | o1js verifies the secp256k1 signature inside a ZkProgram | Proof generates with ECDSA verification as a constraint | ECDSA gadget incompatible with TLSNotary's signature format |
| 3 | o1js eligibility circuit works with attested data | Proof generation succeeds with real attested values | Type mismatches, field encoding issues, circuit too large to compile |
| 4 | Proof verifies locally | `verify()` returns true | Proof is invalid after serialization/deserialization |
| 5 | Proof posts to Zeko testnet | Transaction confirmed on-chain | Zeko rejects proof, SDK doesn't work, testnet unavailable |
| 6 | Total pipeline completes in under 5 minutes | End-to-end < 5 min on a modern laptop (M-series Mac or comparable) | Pipeline hangs or takes unreasonably long |

---

## 10. Key Reference Links

| Resource | URL |
|----------|-----|
| TLSNotary documentation | https://docs.tlsnotary.org/ |
| TLSNotary GitHub repo | https://github.com/tlsnotary/tlsn |
| TLSNotary examples | https://github.com/tlsnotary/tlsn/tree/main/crates/examples |
| TLSNotary releases (check for secp256k1 support) | https://github.com/tlsnotary/tlsn/releases |
| o1js documentation | https://docs.o1labs.org/o1js/ |
| o1js ECDSA documentation | https://docs.minaprotocol.com/zkapps/o1js/ecdsa |
| o1js GitHub repo | https://github.com/o1-labs/o1js |
| Zeko documentation | https://docs.zeko.io/ |
| Zeko getting started | https://docs.zeko.io/developers/getting-started.html |
| Zeko testnet faucet | https://zeko.io/faucet |
| ZKON zkTLS-Mina-Oracle (reference for ECDSA bridge pattern) | https://github.com/ZKON-Network/zkTLS-Mina-Oracle |
| ZKON zkTLS-Mina-zkApp (reference for zkApp integration) | https://github.com/ZKON-Network/zkTLS-Mina-zkApp |
| Lumina DEX (reference for Mina GraphQL interaction) | https://github.com/Lumina-DEX/lumina/blob/main/packages/signer/src/graphql.ts |
| Mina oracle tutorial (reference for signature verification pattern) | https://docs.minaprotocol.com/zkapps/tutorials/oracle |
